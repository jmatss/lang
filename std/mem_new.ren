use std.traits

extern fn malloc(size: u32) -> {u8}
extern fn free(ptr: {u8})
extern fn realloc(ptr: {u8}, size: u32) -> {u8}
extern fn printf(format: {u8}, ...) -> i32
extern fn memcpy(dest: {u8}, src: {u8}, size: u32) -> {u8}

struct Allocator;
impl Allocator
{
    fn init<T>(value: T = @null<T>()) -> {T}
    {
        var ptr = Allocator::init_size<T>(@size<T>())
        ptr.* = value
        return ptr
    }

    fn init_size<T>(size: u32) -> {T}
    {
        var ptr = malloc(size) as {T}
        printf("Allocation (size: %d, ptr: 0x%p)\n", size, ptr)
        return ptr
    }

    fn reinit<T>(ptr: {T}, size: u32) -> {T}
    {
        var new_ptr = realloc(ptr as {u8}, size) as {T}
        if new_ptr == @null<{T}>()
        {
            printf("Reallocation failed (size: %d, ptr: 0x%p)\n", size, new_ptr)
            return ptr
        }
        else
        {
            printf("Reallocation success (size: %d, old_ptr: 0x%p, new_ptr: 0x%p)\n", size, ptr, new_ptr)
            return new_ptr
        }
    }

    fn deinit<T>(ptr: {T})
    {
        printf("Deallocation (ptr: 0x%p)\n", ptr)
        free(ptr as {u8})
    }

    /// Clones `size` bytes from the `src` into a new heap allocation
    /// and returns a pointer to the new allocation.
    /// If `size` isn't set, it will default to the size of `T`.
    /// Implemented using libc `memcpy`.
    fn clone<T>(src: {T}, size: u32 = @size<T>() as u32) -> {T}
    {
        var dest = Allocator::init_size<T>(size)
        memcpy(dest as {u8}, src as {u8}, size)
        return dest
    }

    /// Copies the `size` bytes from `src` to `dest`.
    /// If `size` isn't set, it will default to the size of `T`.
    /// Implemented using libc `memcpy`.
    fn copy<T>(dest: {T}, src: {T}, size: u32 = @size<T>() as u32)
    {
        memcpy(dest as {u8}, src as {u8}, size)
    }
}


/// Represent a heap allocated value of type `T`.
struct Ptr<T> where T impls Disposable
{
    ptr: {T},
}

impl Ptr
{
    /// Allocates a value of type `T` on the heap.
    /// If no `value` is given, the memory will be initialized with null.
    fn init(value: T = @null<T>()) -> Ptr<T>
    {
        return Ptr<T> { Allocator::init<T>(value) }
    }
}

impl Disposable for Ptr
{
    /// Disposes of the allocated heap memory. Before freeing the memory, the inner
    /// value of type `T` is disposed of.
    fn {this} deinit()
    {
        this.*.ptr.deinit()
        Allocator::deinit<T>(this.*.ptr)
    }
}