struct Nullable<T>
{
    value: T,
    is_null: bool,
}

implement Nullable
{
    function this get() -> T
    {
        return this.value
    }

    function this is_null() -> bool
    {
        return this.is_null
    }

    // Creates a new `Nullable` containing the value `value`.
    // If `value` isn't set, the default value will be null.
    function init(value: T = @null<T>()) -> Nullable<T>
    {
        return Nullable<T> { value, false }
    }
}

/*
    class T { a: u32 }
    implement T
    {
        function this do_this() -> u32
        {
            return this.a
        }
    }

    var tmp = people
    if (tmp != null) ? tmp.len() : null

    var tmp = people
    if not tmp.is_null()
    {
        tmp.get()
    }
    else
    {
        null
    }
    
    "Nullable<T> (unknown)".len()

      =>
    
    var result: "Nullable<R> (unknown)"
    if not "Nullable<T> (unknown)".is_null()
    {
        var val = "Nullable<T> (some)".get()
        result = Nullable { val.len(), is_null=false }
    }
    else
    {
        result = Nullable { null, is_null=true }
    }


    var x = Nullable<T>::new(0)
    var y = x.?.len()  //  =>  var y = (x != null) ? x.len() : null;

      =>

    var x = Nullable<T>::new(0)
    var y
    if not x.is_null()
    {
        y = Nullable<R>::new(x.get().len())
    }
    else
    {
        Y = Nullable<R>::new(0)
    }
      where R == @type(x.get().len()) ==  @type(T.len())

      =>

    var x = Nullable<T>::new(0)
    var y
    if not x.is_null()
    {
        y = Nullable<@type(x.get().len())>::new(x.get().len())
    }
    else
    {
        y = Nullable<@type(x.get().len())>::new(0)
    }
      where R == @type(x.get().len()) ==  @type(T.len())



    func_call(x.?.len())    =>   fn func_call(expr: Nullable<R>)
    
*/



