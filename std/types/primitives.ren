mod std::types

use std::container::ArrayList

ext fn abs(value: i32) -> u32

/// Converts a `digit` to ascii.
/// The given `digit` is expected to be a single digit (0-9).
fn digit_to_ascii(digit: u8) -> u8
{
    if digit >= 10
    {
        @unreachable()
    }
    return digit + 48
}

pub struct I8;
impl I8
{
    pub fn to_string(number: i8) -> Result<String, {u8}>
    {
        var is_negative = number < 0
        var number_abs = this::abs(number)

        var buf: [u8: 3]
        var buf_idx = 0

        while true
        {
            var digit = number_abs % 10
            var ascii = digit_to_ascii(digit as u8)
            buf.[buf_idx] = ascii
            buf_idx.++

            number_abs /= 10
            if number_abs == 0
            {
                break
            }
        }

        var str_or_error = String::init_size(buf_idx)
        if err is str_or_error.error
        {
            return Result::error(err)
        }
        var str = str_or_error.&.get_success()

        if is_negative
        {
            str.&.append_ascii(45)  // 45 == '-'
        }

        var idx = buf_idx - 1
        while true
        {
            var ascii = buf.[idx]
            str.&.append_ascii(ascii)

            if idx == 0
            {
                break
            }

            idx.--
        }

        return Result::success(str)
    }
    
    pub fn abs(value: i8) -> u8
    {
        return abs(value as i32) as u8
    }
}

pub struct U8;
impl U8
{
    pub fn to_string(number: u8) -> Result<String, {u8}>
    {
        var buf: [u8: 3]
        var buf_idx = 0

        while true
        {
            var digit = number % 10
            var ascii = digit_to_ascii(digit as u8)
            buf.[buf_idx] = ascii
            buf_idx.++

            number /= 10
            if number == 0
            {
                break
            }
        }

        var str_or_error = String::init_size(buf_idx)
        if err is str_or_error.error
        {
            return Result::error(err)
        }
        var str = str_or_error.&.get_success()

        var idx = buf_idx - 1
        while true
        {
            var ascii = buf.[idx]
            str.&.append_ascii(ascii)

            if idx == 0
            {
                break
            }

            idx.--
        }

        return Result::success(str)
    }
}
