mod std::types

pub union Optional<T>
{
    value: T,
    empty: T,
}

impl Optional
{
    fn value(val: T = @null<T>()) -> Optional<T>
    {
        return Optional<T> { value = val}
    }

    fn empty() -> Optional<T>
    {
        return Optional<T> { empty = @null<T>() }
    }

    fn {this} has_value() -> bool
    {
        if _ is this.*.value
        {
            return true
        }
        else
        {
            return false
        }
    }

    fn {this} is_empty() -> bool
    {
        return not this.has_value()
    }

    // TODO: Calling a function taking this as a pointer with a non-pointer this
    //       will fail during codegen with the error:
    //         "Assertion failed: (i >= FTy->getNumParams() || FTy->getParamType(i) == Args[i]->getType()) && "Calling a function with a bad signature!", file D:\LLVM\llvmenv\10.0.1\lib\IR\Instructions.cpp, line 400"
    //       should be caught during analyzing.
    fn {this} get() -> T
    {
        return this.*.value
    }

    fn {this} get_or(default: T) -> T
    {
        if val is this.*.value
        {
            return val
        }
        else
        {
            return default
        }
    }

    fn {this} set(val: T)
    {
        this.*.value = val
    }
}
