mod std::container

use std::mem::Allocator
use std::types::Disposable
use std::types::Optional
use std::types::Result

pub struct ArrayList<T>
{
    ptr: {T},
    len: u32,
    cap: u32,
}

impl ArrayList
{
    /// Allocates a new ArrayList with a initial capacity of `cap` items.
    ///
    /// If `cap` is set to 0, the current implementation will set the capacity
    /// to 1 so that something can be allocated. This should be changed in the
    /// future so that a ArrayList of size 0 can be lazy initialized and only
    /// make a heap allocation if it is ever used.
    pub fn init(cap: u32 = 0) -> Result<ArrayList<T>, {u8}>
    {
        if cap == 0 { cap = 1 }

        var size = cap * @size<T>()
        var ptr_or_error = Allocator::init_size<u8>(size)
        if err is ptr_or_error.error
        {
            return Result::error(err)
        }

        var ptr = ptr_or_error.&.get_success()
        var list = ArrayList { ptr, 0, cap }

        return Result::success(list)
    }

    pub fn {this} push(item: T) -> Result<u32, {u8}>
    {
        if this.*.len() >= this.*.cap()
        {
            var resize_or_error = this.resize(1)
            if err is resize_or_error.error
            {
                return Result::error(err)
            }
        }

        var item_pos_ptr = @ptr_add(this.*.ptr, this.*.len())
        item_pos_ptr.* = item

        this.*.len.++
        return Result::success(0)
    }

    pub fn {this} pop() -> Optional<T>
    {
        if this.*.len() == 0
        {
            return Optional::empty()
        }

        var idx = this.*.len() - 1
        var item_pos_ptr = @ptr_add(this.*.ptr, idx)
        var item = item_pos_ptr.*
        
        this.*.len.--
        return Optional::value(item)

    }

    pub fn {this} get(idx: u32) -> Optional<T>
    {
        if idx >= this.*.len()
        {
            return Optional::empty()
        }

        var item_pos_ptr = @ptr_add(this.*.ptr, idx)
        var item = item_pos_ptr.*

        return Optional::value(item)
    }

    pub fn {this} set(idx: u32, item: T) -> Result<T, {u8}>
    {
        if idx >= this.*.len()
        {
            var err = "Tried to set value at idx greater than ArrayList length."
            return Result::error(err)
        }

        var item_pos_ptr = @ptr_add(this.*.ptr, idx)
        var old_item = item_pos_ptr.*
        item_pos_ptr.* = item

        return Result::success(old_item)
    }

    pub fn this len() -> u32
    {
        return this.len
    }

    pub fn this cap() -> u32
    {
        return this.cap
    }

    fn {this} resize(min_resize: u32) -> Result<{u8}, {u8}>
    {
        var new_cap = this.*.cap() * 2
        while new_cap - this.*.len() < min_resize
        {
            new_cap *= 2
        }

        var new_ptr_or_empty = Allocator::reinit<u8>(this.*.ptr, new_cap)
        if new_ptr is new_ptr_or_empty.value
        {
            this.*.ptr = new_ptr
            this.*.cap = new_cap
            return Result::success(new_ptr)
        }
        else
        {
            var err = "Unable to reallocate size for ArrayList."
            return Result::error(err)
        }
    }
}

impl Disposable for ArrayList
{
    pub fn {this} deinit()
    {
        if not @is_null(this.*.ptr)
        {
            Allocator::deinit<u8>(this.*.ptr as {u8})
        }
    }
}