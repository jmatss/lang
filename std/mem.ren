mod std::mem

use std::types::Optional
use std::types::Result

//use std::types::Disposable

extern fn malloc(size: u32) -> {u8}
extern fn free(ptr: {u8})
extern fn realloc(ptr: {u8}, size: u32) -> {u8}
extern fn printf(format: {u8}, ...) -> i32
extern fn memcpy(dest: {u8}, src: {u8}, size: u32) -> {u8}

// TODO: Implement error handling. Return "Result"s from functions.

/// A basic heap allocator that can be used to work with heap allocated data.
pub struct Allocator;
impl Allocator
{
    pub fn init<T>(value: T = @null<T>()) -> Result<{T}, {u8}>
    {
        var ptr_or_error = this::init_size<T>(@size<T>())
        if ptr is ptr_or_error.success
        {
            ptr.* = value
        }
        return ptr_or_error
    }

    pub fn init_size<T>(size: u32) -> Result<{T}, {u8}>
    {
        var ptr = malloc(size) as {T}
        if not @is_null(ptr)
        {
            return Result::success(ptr)
        }
        else
        {
            return Result::error("Unable to allocate memory")
        }
    }

    /// Re-allocates the heap memory with a new size `size`.
    /// After a successful re-allocation, the new pointer will returned in the Optional value.
    /// If the allocation failed, the function will return an empty Optional.
    pub fn reinit<T>(ptr: {T}, size: u32) -> Optional<{T}>
    {
        var new_ptr = realloc(ptr as {u8}, size) as {T}
        if not @is_null(new_ptr)
        {
            return Optional::value(new_ptr)
        }
        else
        {
            return Optional::empty()
        }
    }

    pub fn deinit<T>(ptr: {T})
    {
        free(ptr as {u8})
    }
    
    /// Clones `size` bytes from the `src` into a new heap allocation
    /// and returns a pointer to the new allocation.
    /// If `size` isn't set, it will default to the size of `T`.
    /// Implemented using libc `memcpy`.
    fn clone<T>(src: {T}, size: u32 = @size<T>() as u32) -> Result<{T}, {u8}>
    {
        var ptr_or_error = this::init_size<T>(size)
        if dst is ptr_or_error.success
        {
            memcpy(dst as {u8}, src as {u8}, size)
        }
        return ptr_or_error
    }

    /// Copies `size` bytes from `src` to `dst`.
    /// If `size` isn't set, it will default to the size of `T`.
    /// Implemented using libc `memcpy`.
    pub fn copy<T>(dst: {T}, src: {T}, size: u32 = @size<T>() as u32)
    {
        memcpy(dst as {u8}, src as {u8}, size)
    }
}

// TODO: How should this work?
/*
/// Represent a pointer to a heap allocated value of type `T`.
struct Ptr<T> where T impls Disposable
{
    ptr: {T},
}

impl Ptr
{
    /// Allocates a value of type `T` on the heap.
    /// If no `value` is given, the memory will be initialized with null.
    fn init(value: T = @null<T>()) -> Ptr<T>
    {
        return Ptr<T> { Allocator::init<T>(value) }
    }
}

impl Disposable for Ptr
{
    /// Disposes of the allocated heap memory. Before freeing the memory, the inner
    /// value of type `T` is disposed.
    fn {this} deinit()
    {
        this.*.ptr.deinit()
        Allocator::deinit<T>(this.*.ptr)
    }
}
*/