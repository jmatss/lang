extern fn printf(format: {u8}, ...) -> i32

union TestUnion
{
    var_a: f64,
    another: i16,
}

union TestGenericUnion<T>
{
    a: i16,
    b: T,
}

fn main() -> i32
{
    var correct

    var abc = TestUnion { var_a = 123.456 }
    var def = TestUnion { another = 789 }

    if val is abc.var_a
    {
        correct = true
        printf("%f", val)
    }
    else
    {
        correct = false
    }
    std::assert(correct)

    if val is abc.another
    {
        correct = false
    }
    else
    {
        correct = true
        printf("\nabc.another not a match")
    }
    std::assert(correct)

    if val is def.var_a
    {
        correct = false
    }
    else
    {
        correct = true
        printf("\ndef.var_a not a match")
    }
    std::assert(correct)

    if val is def.another
    {
        correct = true
        printf("\n%d", val as i32)
    }
    else
    {
        correct = false
    }
    std::assert(correct)


    var ghi = TestGenericUnion<f32> { a = 12 }
    var jkl = TestGenericUnion { b = 34.56 as f32 }

    if val is ghi.a { correct = true } else { correct = false }
    std::assert(correct)
    if val is ghi.b { correct = false } else { correct = true }
    std::assert(correct)
    if val is jkl.a { correct = false } else { correct = true }
    std::assert(correct)
    if val is jkl.b { correct = true } else { correct = false }
    std::assert(correct)

    jkl.b = 78.90
    std::assert(jkl.b == 78.90)

    // Should result in a compile error since `T` isn't known.
    //var mno = TestGenericUnion { a = 78 }

    return 0
}